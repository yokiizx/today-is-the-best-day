### 重点是各种边界条件

[二分搜索注意点](https://labuladong.github.io/algo/2/18/26/)

```js
// 框架
function binarySearch(nums, target) {
    let left = 0, right = ...;

    while(...) {
        let mid = left + (right - left) / 2 | 0; // 防止溢出
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}

```

#### 寻找一个数

```js
function binarySearch(nums, target) {
  let left = 0
  let right = nums.length - 1 // 注意

  while (left <= right) {
    let mid = left + (right - left) / 2
    if (nums[mid] == target) return mid
    else if (nums[mid] < target) left = mid + 1 // 注意
    else if (nums[mid] > target) right = mid - 1 // 注意
  }
  return -1
}
```

> 初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。

#### 寻找左侧边界

```js
function left_bound(nums, target) {
  if (nums.length == 0) return -1
  let left = 0
  let right = nums.length // 注意
  // 注意
  while (left < right) {
    let mid = left + (right - left) / 2
    if (nums[mid] == target) {
      right = mid // 找到了继续缩小右边界
    } else if (nums[mid] < target) {
      left = mid + 1
    } else if (nums[mid] > target) {
      right = mid // 注意
    }
  }
  return left
}

// 第二种，统一到闭区间，需要处理索引越界
function left_bound(nums, target) {
  let left = 0,
    right = nums.length - 1
  // 搜索区间为 [left, right]
  while (left <= right) {
    let mid = (left + (right - left) / 2) | 0
    if (nums[mid] < target) {
      // 搜索区间变为 [mid+1, right]
      left = mid + 1
    } else if (nums[mid] > target) {
      // 搜索区间变为 [left, mid-1]
      right = mid - 1
    } else if (nums[mid] == target) {
      // 收缩右侧边界
      right = mid - 1
    }
  }
  // 检查出界情况
  if (left >= nums.length || nums[left] != target) {
    return -1
  }
  return left
}
```

#### 寻找右侧边界

```js
function right_bound(nums, target) {
  if (nums.length == 0) return -1
  let left = 0,
    right = nums.length

  while (left < right) {
    let mid = left + (right - left) / 2
    if (nums[mid] == target) {
      left = mid + 1 // 注意
    } else if (nums[mid] < target) {
      left = mid + 1
    } else if (nums[mid] > target) {
      right = mid
    }
  }
  // return left - 1 // 注意
  if (left == 0) return -1
  return nums[left - 1] == target ? left - 1 : -1
}

// 闭区间
function right_bound(nums, target) {
  let left = 0,
    right = nums.length - 1
  while (left <= right) {
    let mid = left + (right - left) / 2
    if (nums[mid] < target) {
      left = mid + 1
    } else if (nums[mid] > target) {
      right = mid - 1
    } else if (nums[mid] == target) {
      // 这里改成收缩左侧边界即可
      left = mid + 1
    }
  }
  // 这里改为检查 right 越界的情况，见下图
  if (right < 0 || nums[right] != target) {
    return -1
  }
  return right
}
```

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/)

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var searchRange = function (nums, target) {
  return [findLeft(nums, target), findRight(nums, target)]
}

function findLeft(nums, target) {
  let left = 0,
    right = nums.length - 1
  while (left <= right) {
    const mid = (left + (right - left) / 2) | 0
    if (nums[mid] === target) {
      right = mid - 1
    } else if (nums[mid] < target) {
      left = mid + 1
    } else if (nums[mid] > target) {
      right = mid - 1
    }
  }
  if (left >= nums.length || nums[left] !== target) {
    return -1
  }
  return left
}

function findRight(nums, target) {
  let left = 0,
    right = nums.length - 1
  while (left <= right) {
    const mid = (left + (right - left) / 2) | 0
    if (nums[mid] === target) {
      left = mid + 1
    } else if (nums[mid] < target) {
      left = mid + 1
    } else if (nums[mid] > target) {
      right = mid - 1
    }
  }
  if (right < 0 || nums[right] !== target) {
    return -1
  }
  return right
}
```
