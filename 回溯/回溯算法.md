### 回溯算法是一种暴力穷举算法

框架和遍历多叉树相似。其实回溯算法和我们常说的 DFS 算法非常类似，本质上就是一种暴力穷举算法。回溯算法和 DFS 算法的细微差别是：回溯算法是在遍历 「树枝」 ，DFS 算法是在遍历 「节点」。

```js
// 框架
const res = []
function backtrack(路径, 选择列表) {
  if (满足结束条件) {
    res.add(路径)
    return
  }
  for (选择 in 选择列表) {
    做选择
    backtrack(路径, 选择列表)
    撤销选择
  }
}
```

> 1、路径： 也就是已经做出的选择。
> 2、选择列表：也就是你当前可以做的选择。
> 3、结束条件：也就是到达决策树底层，无法再做选择的条件。

其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」，特别简单。

复习一下多叉树的遍历框架：

```js
function traverse(root) {
  // 前序位置
  for (let node of root) {
    traverse(node)
  }
  // 后序位置
}
```

在回溯算法中，这个前后序位置在 for 循环内：

```js
function traverse(root) {
  for (let node of root) {
    // 前序位置 做选择
    traverse(node)
    // 后序位置 撤销选择
  }
}
```

> 再次验证了回溯算法和 DFS 算法的细微差别是：回溯算法是在遍历 「树枝」 ，DFS 算法是在遍历 「节点」。

[46.全排列](https://leetcode.cn/problems/permutations/)

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function (nums) {
  const res = [],
    track = [], // 记录track  === path
    used = [] // Array<Boolean>标记路径中的元素是否使用过避免重复使用
  backtrack(nums, track, used)
  return res
  function backtrack(nums, track, used) {
    // 递归结束条件
    if (track.length === nums.length) {
      res.push([...track]) // 一维数组用拓展运算符...深拷贝一下, 因为回溯的时候会改变
      return
    }
    for (let i = 0; i < nums.length; ++i) {
      // 排除不合法的那根树枝, 这根树枝在身后
      if (used[i]) continue
      track.push(nums[i])
      used[i] = true
      backtrack(nums, track, used)
      // 回溯 将push进track 的元素pop出来, 然后表示成未使用, 继续其他分支
      track.pop()
      used[i] = false
    }
  }
}
```

> 通过 used 数组排除已经存在 track 中的元素
> [51.N 皇后](https://leetcode.cn/problems/n-queens/)

抽象为: 决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。
![回溯算法-2022-06-15](https://raw.githubusercontent.com/yokiizx/picgo/main/images/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-2022-06-15.png)

```js
// 首先需要清除怎么判断皇后在棋盘上的位置是否合理。
// 因为是对每一行从左向右遍历, 当放置了一个皇后的时候需要考虑的点一共有三个: 1. 当前列上是否放有皇后; 2. 主对角线上是否放有皇后; 3. 副对角线上是否放有皇后
// 主对角线上坐标值的特点是, x - y 为固定值; 副对角线上的特点是 x + y为固定值
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function (n) {
  // 初始化一个二维棋盘
  const board = Array.from(new Array(n), () => new Array(n).fill('.'))

  // 不像全排列那样一个used就能确定选择条件, 这里需要三个, 分别是列, 主对角线和副对角线
  const cols = new Set()
  const diagnoal1 = new Set()
  const diagnoal2 = new Set()

  const res = [] // 结果集

  // 开始dfs遍历, 这里也就是写一个回溯算法
  // 参数 row 为 path
  const backtrack = row => {
    // 终止条件, 把所有行都遍历完了
    if (row === n) {
      res.push(board.map(item => item.join('')))
      return
    }
    // 遍历
    for (let col = 0; col < n; ++col) {
      if (!isValid(cols, diagnoal1, diagnoal2, row, col)) continue
      // 放置皇后
      board[row][col] = 'Q'
      cols.add(col)
      diagnoal1.add(row - col)
      diagnoal2.add(row + col)
      backtrack(row + 1)
      board[row][col] = '.'
      cols.delete(col)
      diagnoal1.delete(row - col)
      diagnoal2.delete(row + col)
    }
  }
  backtrack(0)
  return res
}
/**
 * @desc    判断皇后位置是否合理
 * @param   {Array}  board - 棋盘
 * @param   {Number} row - 横坐标
 * @param   {Number} col - 纵坐标
 */
function isValid(colSet, diagonal1, diagnoal2, row, col) {
  // 检查列
  if (colSet.has(col)) return false
  // 检查左上方(主对角线)
  if (diagonal1.has(row - col)) return false
  // 检查右上方(副对角线)
  if (diagonal2.has(row + cal)) return false
  return true

  // 上述可以通过传入整个棋盘然后根据row,col来遍历左上方和右上方的方法来判断
  // 也可以通过三个集合存储已占位信息来判断, 在此选择了便捷的第二种
}
```
