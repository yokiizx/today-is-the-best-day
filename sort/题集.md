### 排序相关

[912.排序数组](https://leetcode.cn/problems/sort-an-array/)

> 省略，参考[快速排序](./%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.md)

[315.计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function (nums) {
  // 暴力破解不考虑，时间复杂度n的平方，利用归并排序解决，因为归并排序每次合并的时候，temp[i]赋值给temp[p]的时候，小于temp[i]的个数就是
  // temp[i] < temp[j] 的时候，也就是j - （mid + 1）的个数
  // 利用memo记录原始的数值和索引位置
  const memo = [],
    count = Array.from(new Array(nums.length), _ => 0)

  for (let i = 0; i < nums.length; ++i) {
    memo.push({ val: nums[i], id: i })
  }

  function mergeSort(nums, l, r) {
    if (l === r) return
    const mid = l + ((r - l) >> 2)
    mergeSort(nums, l, mid)
    mergeSort(nums, mid + 1, r)
    merge(nums, l, mid, r)
  }
  const merge = (nums, l, mid, r) => {
    const temp = []
    for (let i = l; i <= r; ++i) {
      temp[i] = nums[i]
    }
    let i = l,
      j = mid + 1
    for (let p = l; p <= r; p++) {
      if (i === mid + 1) {
        nums[p] = temp[j++]
      } else if (j === r + 1) {
        nums[p] = temp[i++]
        // 修改count计数
        count[memo[p].id] += j - mid - 1
      } else if (temp[i].val > temp[j].val) {
        nums[p] = temp[j++]
      } else {
        nums[p] = temp[i++]
        // 修改count计数
        count[memo[p].id] += j - mid - 1
      }
    }
  }
  mergeSort(memo, 0, memo.length - 1)

  return count
}
```

![常见排序算法-2022-05-19](https://raw.githubusercontent.com/yokiizx/picgo/main/images/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-2022-05-19.png)

[327.区间和的个数](https://leetcode.cn/problems/count-of-range-sum/)

```js
// 归并排序，前缀和数组，滑动窗口技巧性较强，后期学习。https://labuladong.gitee.io/algo/2/19/38/
```

[215. 数组中的第 K 个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
两种解法，一种是二叉堆（优先队列）的解法，另一种就是快速选择算法(快速排序的变体)

```js

```

[493.反转对](https://leetcode-cn.com/problems/reverse-pairs/)

```js

```
