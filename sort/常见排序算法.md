几种常见排序算法

#### 冒泡排序

时间：O(n^2)，空间：O(1)

```js
// 从左往右，两两比较，冒出极值
function bubble(nums) {
  for (let i = 0; i < nums.length; i++) {
    let sorted = true
    // 减i，是减去已经排好序的
    for (let j = i; j < nums.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        ;[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]
        sorted = false // 没有进入该行，说明挡圈已经在正确的位置了，可以跳出本轮循环
      }
    }
    if (sorted) break
  }
}
```

#### 插入排序

时间：O(n^2)，空间：O(1)

```js
// 通过构建有序数列，对未排序的数据在已经排序的序列中从后向前扫描，找到相应的位置并插入
function insert(nums) {
  // 第一个已经排好序了,可以直接从第二个开始
  for (let i = 1; i < nums.length; i++) {
    let prev = i - 1,
      num = nums[i] // 指针，和当次需要排序的元素
    while (prev >= 0 && nums[prev] > num) {
      nums[prev + 1] = nums[prev] // 排好的元素后移
      prev--
    }
    nums[prev + 1] = num
  }
}
```

#### 选择排序

时间：O(n^2)，空间：O(1) 不稳定

```js
// 选择排序, 从左往右选择每一项作为极值,去和剩下的做比较,从该修改极值的索引,然后交换
function select(nums) {
  // 最后一项没有必要比较
  for (let i = 0; i < nums.length - 1; i++) {
    let minIndex = i
    // 和剩下的比较, 找到最小的索引
    for (let j = i + 1; j < nums.length; j++) {
      if (nums[minIndex] > nums[j]) {
        minIndex = j
      }
    }
    if (minIndex !== i) {
      ;[nums[minIndex], nums[i]] = [nums[i], nums[minIndex]]
    }
  }
}
```

#### 快速排序

时间：O(nlogn)，空间：O(logn) 不稳定

```js
// 快速排序就是二叉树的前序遍历。
// 随机选择一个数作为基准，大于放右，小于放左，这样就确定了该基数的位置，对两边做相同的操作
function quickSort (nums, l, r) {
  if (l >= r) return
  const partitionIndex = partition(nums, l, r);
  quickSort(nums, l, partitionIndex - 1);
  quickSort(nums, partitionIndex + 1, r);

}
const partition = (nums, l, r) => {
  const randomIndex = l + Math.random() * (r - l) | 0 // js的减法是不准的，对最后的进行向0取整
  // 与第一个交换
  [nums[l], nums[randomIndex]] =[nums[randomIndex], nums[l]]
  const pivot = nums[l]
  let i = l + 1, j = r
  // 对基准之外的元素进行交换，让左边的都小于基准，右边的都大于基准
  while (i <= j) {
    while (nums[i] <= pivot && i < r) {
      i++
    }
    while (nums[j] > pivot && j > l) {
      j--
    }
    if (i >= j) break
    [nums[i], nums[j]] = [nums[j], nums[i]]
  }
  // 把基准元素放到正确的位置
  [nums[l], nums[j]] = [nums[j], nums[l]]
  return j
}
```

> 变体，快速选择算法，见题集 215

#### 归并排序

时间：O(nlogn)，空间：O(logn)

```js
// 归并排序就是二叉树的后序遍历
function mergeSort(nums) {
  // 定义: 对nums[l..r]排序后进行合并
  const sort = (nums, l, r) => {
    if (l === r) return // 单个元素不用排序
    // const mid = Math.floor(l + (r - l) / 2)
    const mid = l + ((r - l) >> 1) // 1.防止溢出,2.算数运算符的优先级高于位运算符
    sort(nums, l, mid)
    sort(nums, mid + 1, r)
    merge(nums, l, mid, r)
  }
  const merge = (nums, l, mid, r) => {
    // 辅助合并
    const temp = []
    // 对数组进行一次深拷贝，便于后续合并时直接存入原nums中
    for (let i = 0; i <= r; i++) {
      temp[i] = nums[i]
    }
    // 双指针合并两个有序数组
    let i = l,
      j = mid + 1
    for (let p = l; p <= r; p++) {
      // 先判断边界
      if (i === mid + 1) {
        // 左边加完了,右边按序加入
        nums[p] = temp[j++]
      } else if (j === r + 1) {
        // 左边加完了,右边按序加入
        nums[p] = temp[i++]
      } else if (temp[i] > temp[j]) {
        nums[p] = temp[j++]
      } else {
        // 这一步temp[i]<=temp[j]的操作一定是在最后，因为放到前面，可能会导致j已经越界，但是又满足此情况。
        nums[p] = temp[i++]
      }
    }
  }
  sort(nums, 0, nums.length - 1)
}
```

#### 希尔排序

时间：，空间：

```js

```

#### 堆排序

时间：，空间：

```js

```
