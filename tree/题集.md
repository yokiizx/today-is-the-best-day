1. [226.反转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```js
// 1. 遍历每个节点，交换左右节点
var invertTree = function (root) {
  const traversal = node => {
    if (!node) return;
    [node.left, node.right] = [node.right, node.left];
    traversal(node.left);
    traversal(node.right);
  };
  traversal(root);
  return root;
};
// 2. 遍历节点，交换子树，涉及到子树，后序遍历
var invertTree = function (root) {
  if (!root) return null;
  const left = invertTree(root.left);
  const right = invertTree(root.right);
  root.left = right;
  root.right = left;
  return root;
};
```

| 前序,后序都可以遍历；需要注意的是中序遍历会有问题，因为会有节点被交换两次

2. [114.二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
// 第一眼觉得，一个前序遍历就能完成
var flatten = function (root) {
  const dummy = new TreeNode(-1); // 虚拟头结点
  let p = dummy; // p指针穿针引线，构造链表
  const traversal = node => {
    if (!node) return;
    p.right = new TreeNode(node.val);
    p = p.right;
    traversal(node.left);
    traversal(node.right);
  };
  traversal(root);
  console.log(dummy.right); // 打印出来的结果与预期一致，然后并不是在原地修改
  return dummy.right;
};
// 然而题目是要求在原节点上进行操作，所以遍历不行，那就进行分解子问题，如下图
// 定义：拉平以root为根的树, 与子树有关,应当为后序遍历. 注意是原地修改,所以无需返回值,有返回也可以但是会提高空间复杂度
var flatten = function (root) {
  if (!root) return;
  // flatten拉平了左右子树
  flatten(root.left);
  flatten(root.right);
  const left = root.left;
  const right = root.right;
  /************ 每一轮拉平后,在后序位置把左子树插入到根和右子树中间 **************/
  // 左子树置为空，嫁接到右子树
  root.left = null;
  root.right = left;
  // 再借用一个指针把原先的右子树挂到左子树下(当前右子树)
  let p = root;
  while (p.right) {
    p = p.right;
  }
  p.right = right;
};
```

![题集-2022-05-09](https://raw.githubusercontent.com/yokiizx/picgo/main/images/%E9%A2%98%E9%9B%86-2022-05-09.png)

3. [116.填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```js
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function (root) {
  if (!root) return root;
  const traverse = (node1, node2) => {
    if (!node1 || !node2) return;
    // 前序位置操作，无需返回值
    // node.left.next === node.right; 普通遍历一个node: 这样做无法使得不同父节点的sibling相连接, 需要想象为遍历三叉树如下图
    node1.next = node2;
    traverse(node1.left, node1.right);
    traverse(node2.left, node2.right);
    traverse(node1.right, node2.left);
  };
  traverse(root.left, root.right);
  return root;
};
```

| 此题当然也可以用层序遍历完成，但是时间复杂度为 O(N)

```js
var connect = function (root) {
  if (!root) return root;
  const queue = [root];
  while (queue.length) {
    const size = queue.length;
    for (let i = 0; i < size; ++i) {
      const node = queue.shift();
      if (i < size - 1) {
        node.right = queue[0];
      }
      if (node.left) queue.push(node.left);
      if (node.right) queue.push(node.right);
    }
  }
  return queue;
};
```

---

构造树的思路：一般都是分解问题，而不是遍历每个节点。
构造整棵树 = 根节点 + 构造左子树 + 构造右子树

[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function (nums) {
  if (!nums.length) return null;
  // 思路就是找到最大值作为根节点，返回根节点，然后对左右重复操作
  const traverse = arr => {
    if (!arr.length) return null;
    const max = Math.max(...arr);
    const maxIndex = arr.indexOf(max);
    const left = arr.slice(0, maxIndex);
    const right = arr.slice(maxIndex + 1);
    const root = new TreeNode(max);
    root.left = traverse(left);
    root.right = traverse(right);
    return root;
  };
  return traverse(nums);
};
```

[105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
![题集-2022-05-10](https://raw.githubusercontent.com/yokiizx/picgo/main/images/%E9%A2%98%E9%9B%86-2022-05-10.png)

```js
/*
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function (preorder, inorder) {
  // 利用map缓存中序遍历的值对应的索引
  const n = inorder.length;
  const map = new Map();
  for (let i = 0; i < n; i++) {
    map.set(inorder[i], i);
  }
  const build = (preorder, inorder, pl, pr, il, ir) => {
    if (pl > pr) return null;
    const rootVal = preorder[pl];
    const root = new TreeNode(rootVal);
    const indexInorder = map.get(rootVal);
    const ilSize = indexInorder - il;
    root.left = build(preorder, inorder, pl + 1, pl + ilSize, il, indexInorder);
    root.right = build(preorder, inorder, pl + ilSize + 1, pr, indexInorder + 1, ir);
    return root;
  };
  return build(preorder, inorder, 0, n - 1, 0, n - 1);
};
```

| 突破口：前序遍历每一个子树第一个总是根，此根在中序遍历中，把树分为左右两个部分。所以构造二叉树，无非就是在找四个个端点而已。

[106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
[889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)
