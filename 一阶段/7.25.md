28. strStr() 考察 kmp 算法

    kmp 简单点讲就是我的文本串指针 永不后退！！！ 牺牲空间换时间（存储模式串应该匹配的位置）

    前置条件："真前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"真后缀"指除了第一个字符以外，一个字符串的全部尾部组合。
    **对于长度为 m 的字符串 s，其前缀函数 `pi(i) (0≤i<m)` 表示 ss 的子串 s[0..i] 的最长的相等的真前缀与真后缀的长度。**
    `pi(0) = 0`

          移动位数 = 已匹配的字符数 - 对应的部分匹配值(即pi(i))。

    > 当然了，本题并不打算在代码中这样做，会很麻烦。主要使用前缀函数性质。
    > 可以假想把 pat 和 txt 通过特殊符号#连接起来。然后求前缀函数，分别遍历 pat, txt.
    > 对 pat 保存前缀函数值, 对 txt 无需保存,当前缀值等于 pat 的长度时，就是匹配上了，返回索引为 j - m + 1

```js
var strStr = function (haystack, needle) {
  // 虽然是简单题，但是使用的是并不简单的 KMP！
  // kmp简单点讲就是我的文本串指针 永不后退！！！ 牺牲空间换时间（存储模式串应该匹配的位置）
  const m = haystack.length
  const n = needle.length
  const pi = new Array(n).fill(0)
  // 对pat求前缀函数, 利用前缀函数的性质, 用j指针来处理前缀
  for (let j = 0, i = 1; i < n; ++i) {
    while (j > 0 && needle[j] !== needle[i]) {
      j = pi[j - 1]
    }
    if (needle[j] === needle[i]) j++
    pi[i] = j
  }
  console.log(pi)
  // i txt指针, j pat指针
  for (let i = 0, j = 0; i < m; ++i) {
    while (j > 0 && haystack[i] !== needle[j]) {
      j = pi[j - 1]
    }
    if (haystack[i] === needle[j]) j++
    if (j === n) {
      return i - n + 1
    }
  }
  return -1
}
```

### 参考

- [字符串匹配的 KMP 算法](https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

- [leetcode 解](https://leetcode.cn/problems/implement-strstr/solution/shi-xian-strstr-by-leetcode-solution-ds6y/)

- [前缀函数与 kmp 算法](https://oi-wiki.org/string/kmp/)

- [有限状态机之 KMP 字符匹配算法](https://labuladong.github.io/algo/3/28/97/)

29. 两数相除,不能使用除法,第一反应是使用减法,但是效率太低。可以使用位运算符,并且使用翻倍的技巧去缩小范围.

> 注意边界条件和符号就好了

```js
/**
 * @param {number} dividend
 * @param {number} divisor
 * @return {number}
 */
var divide = function (dividend, divisor) {
  const min = (-2) ** 31,
    max = 2 ** 31 - 1
  if (dividend === 0) return 0
  if (divisor === 0) return Infinity
  if (dividend === min && divisor === -1) return max // 防止溢出

  const negitive = (dividend ^ divisor) < 0 // 异或判断正负技巧

  dividend = Math.abs(dividend)
  divisor = Math.abs(divisor)

  let res = 0
  while (dividend >= divisor) {
    let temp = divisor,
      m = 1
    // 注意：位移运算符的优先级比比较高
    while (temp <= dividend >> 1) {
      temp <<= 1
      m <<= 1
    }
    dividend -= temp
    res += m
  }

  return negitive ? -res : res
}
```
