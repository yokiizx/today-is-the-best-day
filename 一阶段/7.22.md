20. 利用栈解决即可,注意 map 设置的顺序

```js
var isValid = function (s) {
  // 栈解决，如果最后栈没有清空就是不合格的
  const stack = []
  const map = {
    ')': '(',
    '}': '{',
    ']': '['
  }
  for (const c of String(s)) {
    if (Object.values(map).includes(c)) {
      stack.push(c)
    } else {
      if (stack[stack.length - 1] === map[c]) {
        stack.pop()
      } else {
        stack.push(c)
      }
    }
  }
  return stack.length === 0
}
```

21. 看见排序, 可以考虑一下 双指针, 链表, 对头部操作可以考虑 dummy 虚拟头节点，很简单的技巧，可以联想到优先队列的头部也是可以用一个 null 来占位来实现.

```js
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {
  // 有排序, 大概率双指针就可以搞定的啦
  let dummy = new ListNode(-1)
  let p1 = list1,
    p2 = list2,
    p = dummy
  while (p1 && p2) {
    const val1 = p1 ? p1.val : null
    const val2 = p2 ? p2.val : null
    if (val1 < val2) {
      p.next = p1
      p1 = p1.next
    } else {
      p.next = p2
      p2 = p2.next
    }
    p = p.next
  }
  if (p1) p.next = p1
  if (p2) p.next = p2
  return dummy.next
}
```

22. 生成括号,回溯算法.
    1. 选择列表就两个不用 for 循环了,挨个使用
    2. 剪枝条件, 1.右括号使用的多,就不能生成; 2.任何一个括号使用完了就截止

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function (n) {
  // 这种需要各种组合的就可以考虑下回溯算法了
  // 构造括号n个, 左括号n个, 右括号也是n个, 递归回溯
  const res = [],
    track = []
  // 选择列表是根据两个n来处理的
  const backtrack = (track, left, right) => {
    // 注意剪枝条件,1. 当右括号使用数大于左括号使用数就是不合格的
    // 2. 当左括号或者右括号用完了,也就结束了
    if (left > right) return // 右边用的多不合格
    if (left < 0 || right < 0) return
    if (left === 0 && right === 0) {
      res.push(track.join('')) // 注意要对track进行一次深拷贝(单层)
      return
    }
    // 一共就两个选择,左括号和右括号,所以不用for循环,直接选选择(,后选择)来做回溯
    track.push('(')
    backtrack(track, left - 1, right)
    track.pop()
    track.push(')')
    backtrack(track, left, right - 1)
    track.pop()
  }
  backtrack(track, n, n) // 回溯算法，递归找出所有结果
  return res
}
```
