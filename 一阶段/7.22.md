20. 利用栈解决即可,注意 map 设置的顺序

```js
var isValid = function (s) {
  // 栈解决，如果最后栈没有清空就是不合格的
  const stack = []
  const map = {
    ')': '(',
    '}': '{',
    ']': '['
  }
  for (const c of String(s)) {
    if (Object.values(map).includes(c)) {
      stack.push(c)
    } else {
      if (stack[stack.length - 1] === map[c]) {
        stack.pop()
      } else {
        stack.push(c)
      }
    }
  }
  return stack.length === 0
}
```

21. 看见排序, 可以考虑一下 双指针, 链表, 对头部操作可以考虑 dummy 虚拟头节点.

```js
/**
 * @param {ListNode} list1
 * @param {ListNode} list2
 * @return {ListNode}
 */
var mergeTwoLists = function (list1, list2) {
  // 有排序, 大概率双指针就可以搞定的啦
  let dummy = new ListNode(-1)
  let p1 = list1,
    p2 = list2,
    p = dummy
  while (p1 && p2) {
    const val1 = p1 ? p1.val : null
    const val2 = p2 ? p2.val : null
    if (val1 < val2) {
      p.next = p1
      p1 = p1.next
    } else {
      p.next = p2
      p2 = p2.next
    }
    p = p.next
  }
  if (p1) p.next = p1
  if (p2) p.next = p2
  return dummy.next
}
```
