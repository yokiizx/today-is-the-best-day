1. 重点: map 数据结构 目标值 need

```js
/*
 * @lc app=leetcode.cn id=1 lang=javascript
 *
 * [1] 两数之和
 */

// @lc code=start
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
  const map = new Map()
  const res = []
  for (let i = 0; i < nums.length; ++i) {
    const need = target - nums[i]
    if (!map.has(need)) {
      map.set(nums[i], i)
    } else {
      res.push(...[i, map.get(need)]) // push
    }
  }
  return res
}
// @lc code=end
```

2. 重点: carry 进位(相加时和最后的进位), dummy 虚拟节点, p 指针穿针引线

```js
/*
 * @lc app=leetcode.cn id=2 lang=javascript
 *
 * [2] 两数相加
 */

// @lc code=start
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function (l1, l2) {
  let carry = 0,
    dummy = new ListNode(-1),
    p = dummy
  while (l1 || l2) {
    const val1 = l1 ? l1.val : 0
    const val2 = l2 ? l2.val : 0
    const sum = val1 + val2 + carry
    carry = (sum / 10) | 0
    const val = sum % 10
    p.next = new ListNode(val)
    p = p.next
    l1 = l1 && l1.next // 想要使用的时候就要考虑是否有该节点
    l2 = l2 && l2.next
  }
  if (carry) p.next = new ListNode(carry) // 注意处理最后的进位
  return dummy.next
}
// @lc code=end
```

3. 重点: 滑动窗口, 双指针, 注意收缩的条件。两个 while 外部增加，内部减少，状态更新。

```js
/*
 * @lc app=leetcode.cn id=3 lang=javascript
 *
 * [3] 无重复字符的最长子串
 */

// @lc code=start
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
  // 子串 --> 滑动窗口 window和双指针
  const window = new Map()
  let left = (right = 0)
  let max = 0
  while (right < s.length) {
    const c = s[right]
    right++
    window.set(c, window.has(c) ? window.get(c) + 1 : 1)
    // 收缩左边界
    while (window.get(c) > 1) {
      max = Math.max(max, left - right)
      const d = s[left]
      left++
      window.set(d, window.get(d) - 1)
    }
    max = Math.max(max, right - left)
  }
  return max
}
// @lc code=end
```

> ```js
> // 子串需要的字符和合格数 本题不需要
> const need = new Map()
> let isValid = 0
> for (const key of s) {
>   need.set(key, need.has(key) ? need.get(key) + 1 : 1)
> }
> ```


