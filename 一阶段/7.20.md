15. 三数四数之和与第一题两数之和略有差别的是，第一题找的是下标，用 map 数据结构即可搞定，三四之和求得是不同的元素组合，那么就可以使用排序 + 双指针的技巧去解决了。通用方法加上递归即可。

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
  // 三数之和依赖于两数之和,写出一个通用的函数多少数之和都不怕,就是需要注意重复问题
  // 排序 + 双指针搞定
  nums.sort((a, b) => a - b)
  return nSum(nums, 3, 0, 0)
}

// 递归遍历每一个数字，找出n数之和, 调用钱nums一定是排好序的
/**
 * @desc    n数之和
 * @param   {Array}   nums   好序的数组
 * @param   {Number}  n      多少个之和
 * @param   {Array}   nums   每一个位置遍历起始
 * @param   {Number}  target 目标和
 */
function nSum(nums, n, start, target) {
  // 边界条件
  const res = []
  const len = nums.length
  if (n < 2 || len < n) return res
  // 两数之和
  if (n === 2) {
    let l = start,
      r = len - 1
    while (l < r) {
      const left = nums[l],
        right = nums[r]
      const sum = left + right
      if (sum < target) {
        while (l < r && nums[l] === left) l++
      } else if (sum > target) {
        while (l < r && nums[r] === right) r--
      } else {
        res.push([left, right])
        while (l < r && nums[l] === left) l++
        while (l < r && nums[r] === right) r--
      }
    }
  } else {
    // 对每个位置元素求(n-1)nSum
    for (let i = 0; i < len; i++) {
      const subs = nSum(nums, n - 1, i + 1, target - nums[i]) // 递归求出子集
      for (const sub of subs) {
        sub.push(nums[i]) // 子集和+当前数字就是一个合规的组合
        res.push(sub) // 合规的组合放入结果集
      }
      while (i < len - 1 && nums[i] === nums[i + 1]) i++ // 一定记得: 相同的num过滤防止重复
    }
  }
  return res
}
```

针对本题的一般解法，依然是排序+双指针，并且注意去重

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function (nums) {
  // 三数之和依赖于两数之和,写出一个通用的函数多少数之和都不怕,就是需要注意重复问题
  // 排序 + 双指针搞定
  const len = nums.length
  if (len < 3) return []
  nums.sort((a, b) => a - b)
  const res = []
  // 对每一个数字寻找合格项
  for (let i = 0; i < len; ++i) {
    if (nums[i] > 0) break // 因为排好序了,所以当数字大于0的时候可以停止遍历
    if (i > 0 && nums[i] == nums[i - 1]) continue // 注意这里还有个 去重
    let l = i + 1,
      r = len - 1
    while (l < r) {
      const sum = nums[i] + nums[l] + nums[r]
      if (sum === 0) {
        res.push([nums[i], nums[l], nums[r]])
        while (l < r && nums[l] === nums[l + 1]) l++
        while (l < r && nums[r] === nums[r - 1]) r--
        // 上方去重后注意指针仍然落在相同的数字上,需要继续往后移动一下
        l++
        r--
      } else if (sum < 0) {
        l++
      } else {
        r--
      }
    }
  }
  return res
}
```

16. 与上题三叔之和非常相似, 只不过是做了个求绝对值而已，老样子排序加双指针，注意去重和满足条件就好。

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var threeSumClosest = function (nums, target) {
  // 依然排序 + 双指针
  let abs = Infinity
  nums.sort((a, b) => a - b)
  for (let i = 0; i < nums.length; ++i) {
    if (i > 0 && nums[i] === nums[i - 1]) continue // 去重
    let l = i + 1,
      r = nums.length - 1
    while (l < r) {
      const sum = nums[i] + nums[l] + nums[r]
      if (sum === target) {
        return sum
      }
      if (Math.abs(sum - target) < Math.abs(abs - target)) {
        abs = sum
      }
      if (sum < target) {
        l++
      } else if (sum > target) {
        r--
      }
    }
  }
  return abs
}
```
